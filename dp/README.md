## 简介

> 和DP的相爱相杀

的确, 和网上的很多总结类似, 做到后面也感觉DP使用的数学知识就是数学归纳法, 然后还有自身的优化, 譬如大多数情况自底向上的DP往往要比自顶向下的DP实现起来简约且效率高, 也可使用滚动数组将高纬的dp数组降维.

### 两大特性

1. 无后效行

   - 一旦f(i,j)确定，就不用关心 “我们如何计算出f(i,j)”。
   - 想要确定f(i,j)，只需要知道f(i-1,j)和f(i,j-1)的值，而至于它们 是如何算出来的，对当前或之后的任何子问题都没有影响。
   - 过去不依赖将来，将来不影响过去 --- 智巅语录

2. 最优子结构

   1. f(i,j)的定义就已经蕴含了“最优”。

   2. 大问题的最优解可以由若干个小 问题的最优解推出。(max,

      min, sum...)

**DP能适用的问题:能将大问题拆成几个小问题，且满足无后效性、最优子结构性质。**

## 题目特点

1. 计数
   1. 有多少种方式走到右下角
   2. 有多少种方法选出k个数使得和是sum
2. 求最大值最小值
   1. 从左上角走到右下角路径的最大数字和
   2. 最长上升子序列长度
3. 求存在性
   1. 取石子游戏，先手是否必胜
   2. 能不能选出k个数使得和是sum

## 主要类型

### I:时间序列模型

给出一个序列（字符串、数组），其中每一个元素可以认为一天，并且**今天**的状态只取决于**昨天**的状态

**套路**

* 定义$dp[i][j]$： 表示第i-th轮的第j种状态（j=1,2,3,..k）
* 千方百计将$dp[i][j]$和前一轮的状态$dp[i-1][j]$产生关系（j=1,2,3,..k）
* 最后的结果就是$dp[last][j]$的某种操作（sum、max、min...）

![image-20210503140232767](https://i.loli.net/2021/05/03/pH6t78sQ1OcbyxC.png)

### II:时间序列加强版(子序列模型)

给出一个序列（数组、字符串），其中每一个元素可以认为**一天**，但是**今天**的状态和之前的**某一天**相关，需要进行挑选

**套路**

* 定义$dp[i]$: 表示第i-th轮的状态，一般这个状体要求和<u>元素i直接相关</u>:question:
* 千方百计的将$dp[i]$与之前的状态$dp[i']$产生关系（i=1,2,3..i-1）操作如（sum、max、min）
  * $dp[i]$肯定不能与大于 i的轮次有任何关系，否 则违反了DP 的无后效性。
* 最终的结果为$dp[i]$中的某一个

<img src="https://i.loli.net/2021/05/03/VeSxlBqgs3hAuWf.png" alt="image-20210503141804480" style="zoom:50%;" />

### III:双序列模型

给出两个序列$S$和$T$ (数组、字符串)，对它们两个搞事情

* 编辑距离公式

**套路：**

* 定于$dp[i][j]$: 表示针对$S[1:i]$和$T[1:j]$的子问题的求解
* 千方百计将$dp[i][j]$往之前的状态去转移：$dp[i-1][j], dp[i][j-1], dp[i-1][j-1]$
* 最终的结果为$dp[m][n]$

### IV:第I类区间型DP

给出一个序列（数组、字符串），明确要求分割成**k个连续空间**，要你计算这些区间的某个最优性质。

**套路**

* 状态定义：$dp[i][k]$表示针对$S[1:i]$分成**k个区间**，此时能够得到的最优解
* 搜寻最后一个区间的起始位置$j$，将$dp[i][k]$分割成$dp[j-1][k-1]$和两个部分
* 最终的结果是$dp[N][K]$

![image-20210503143245100](https://i.loli.net/2021/05/03/BaXHZ6tGKTwPkpF.png)

### V:第II类区间型DP

只给出一个序列S（数组、字符串），求一个针对这个序列的最优解

**适合条件：** 这个最优解对于序列的index而言，没有**“无后效性”**。即无法设计$dp[i]$使得 $dp[i]$仅依赖于$dp[j] (j<i)$. 但是大区间的最优解，可以依赖小区间的最优解。

**套路：**

* 定义$dp[i][j]$:表示针对$s[i:j]$的子问题的求解。
* 千方百计将最大区间的$dp[i][j]$往小区间的$dp[i'][j']$转移
  * 第一层循环是区间大小；第二层循环是起始点
* 最终的结果是$dp[1][N]$

![image-20210503144732050](https://i.loli.net/2021/05/03/uphPcL5YEI81MTg.png)

### VI:背包入门

题目抽象：给出N件物品，每个物品可用不可用（若干种不同的用法）需要消耗一定的代价。要求以某个有上限C的代价来实现最大收益。（有时候反过来，要求以某个有下限的收益来实现 最小代价。）

**套路：**

* 定义$dp[i][j]$表示只从前i件物品的子集里面选择、代价为$j$的最大收益
  * j = 1、2、3、4...C
* 千方百计的将$dp[i][j]$往$dp[i-1][j']$转移：考虑如何使用物品i，对代价/收益的影响
  * 第一层建议循环物品
  * 第二层建议循环容量/代价
* 最后的结果$max\{dp[N][c]\} | c \in \{1,2,..c\}$

## 
